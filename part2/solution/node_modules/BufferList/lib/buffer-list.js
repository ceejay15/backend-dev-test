function BufferList() {
    //
    // Buffers we are handling
    //
    this.buffers = [];
    this.queries = [];
}
module.exports = BufferList;
BufferList.prototype.push = function push() {
    if (arguments.length === 0) return this.buffers.push();
    var result = this.buffers.push.apply(this.buffers, arguments);
    var queries = this.queries;
    this.queries = [];
    var self = this;
    queries.forEach(function (query) {
       ({slice:self.slice,indexOf:self.indexOf}[query.type]).apply(self, query.args); 
    });
    return result;
}
//
// Purge everything before index
//
BufferList.prototype.purge = function purge(index) {
    var buffers = this.buffers;
    var needle = 0;
    for (var i = 0; i < buffers.length; i++) {
        var buffer = buffers[i];
        var nextLength = needle + buffer.length;
        if (nextLength >= index) {
            var err;
            this.queries.forEach(function(query) {
               var rangeStart = {slice:0,indexOf:1}[query.type]
               var args = query.args;
               args[rangeStart] -= index;
               if (args[rangeStart] < 0) {
                  args[rangeStart + 2](err || (err = new Error('purged')));
               }
               else {
                   query.args[rangeStart + 1] -= index;
               }
            });
            if (nextLength === index) {
                return buffers.splice(0, i + 1);
            }
            return buffers.splice(0, i + 1, buffer.slice(index - needle));
        }
        needle += buffer.length;
    }
    return this;
}
BufferList.prototype.indexOf = function indexOf(pattern, start , end, callback) {
    var length = pattern.length;
    if (length === 0) throw new Error('cannot have a pattern of 0 length')
    var matched = 0;
    var index = 0;
    var result = -1;
    start = start == null ? 0 : +start;
    end = end == null ? Infinity : +end;
    var index = 0;
    search_loop:
    for(var i = 0; i < this.buffers.length; i++) {
        var buffer = this.buffers[i];
        if (index + buffer.length >= start) {
            for(var ii = 0; ii < buffer.length; ii++) {
                var trueIndex = index + ii;
                if (trueIndex < start) continue;
                if (trueIndex >= end) break search_loop;
                if (buffer[ii] === pattern[matched]) {
                    matched++;
                }
                else if (matched) {
                    ii -= matched - 1;
                    while (ii < 0) {
                        buffer = this.buffers[--i];
                        ii += buffer.length;
                        index -= buffer.length - 1;
                    }
                    matched = 0;
                }
                if (matched === length) {
                    result = trueIndex - length + 1;
                    break search_loop;
                }
            }
        }
        index += buffer.length;
    }
    if (callback) {
        if (result !== -1) {
            callback(false, result);
        }
        else {
            this.queries.push({type:'indexOf',args:arguments})
        }
    }
    return result;
}
//
// Callback, tells the bufferlist to wait until the data is available
//
BufferList.prototype.slice = function slice(start, end, callback) {
    var result;
    if (start === end) {
        throw new Error('cannot have a slice of 0 length')
    }
    var index = 0;
    var startBuffer;
    var startBufferIndex;
    var startOffset;
    var endBuffer;
    var endBufferIndex;
    var endOffset;
    var lookingForStart = true;
    var found = false;
    for(var i = 0; i < this.buffers.length; i++) {
        var buffer = this.buffers[i];
        if (lookingForStart && index + buffer.length >= start) {
            lookingForStart = false;
            startBuffer = buffer;
            startBufferIndex = i;
            startOffset = start - index;
        }
        if (index + buffer.length >= end) {
            endBuffer = buffer;
            endBufferIndex = i;
            endOffset = end - index;
            found = true;
            break;
        }
        index += buffer.length;
    }
    if (found) {
        if (startBuffer === endBuffer) {
            result = startBuffer.slice(startOffset, endOffset);
        }
        else {
            var result = new Buffer(end - start),
                index = startBuffer.length - startOffset;
            startBuffer.copy(result, 0, startOffset);
            for(var i = startBufferIndex + 1; i < endBufferIndex; i++) {
                var buffer = this.buffers[i];
                buffer.copy(result, index);
                index += buffer.length;
            }
            endBuffer.copy(result, index, 0, endOffset);
        }
    }
    else {
        if (callback) {
            this.queries.push({type:'slice', args:arguments});
        }
        return null;
    }
    if (callback) {
        callback(false, result);
    }
    return result;
}
