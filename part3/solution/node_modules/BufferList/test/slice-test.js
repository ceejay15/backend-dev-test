var vows = require('vows');
var BufferList = require('../');
var assert = require('assert');

var list = new BufferList();
list.push(new Buffer(''));
list.push(new Buffer('a'));
list.push(new Buffer('bc'));
list.push(new Buffer('d'));
list.push(new Buffer(''));
list.push(new Buffer('efg'));
list.push(new Buffer('hijklmn'));
list.push(new Buffer('o'));
list.push(new Buffer('p'));
list.push(new Buffer('q'));
list.push(new Buffer(''));
list.push(new Buffer('r'));
list.push(new Buffer(''));
list.push(new Buffer('a'));
list.push(new Buffer(''));

vows.describe('buffer-list/indexOf').addBatch({
    "BufferList's #slice": {
        topic: function () {
            this.list = list;
            return list;
        },
        "should handle slices across multiple buffers": function () {
            var slice = this.list.slice(1,5);
            for(var i = 0; i < slice.length; i++) {
                assert.equal(slice[i], 'bcde'.charCodeAt(i));
            }
        }
    }
}).addBatch({
    "BufferList's #slice with a callback": {
        topic: function () {
            this.list = list;
            var self;
            this.list.slice(0, 1, function (err, slice) {
                list.premadeSliceCalled = true;
            })
            this.list.slice(0, 10, function (err, slice) {
                list.calledSliceCallback = true;
            });
            this.callback();
        },
        "should not fire callbacks if the slice is not yet available": function () {
            assert.isTrue(list.premadeSliceCalled)
            assert.isFalse(!!this.calledSliceCallback)
        },
        "after adding the slice": {
            topic: function () {
                this.list.push(new Buffer('fghijklmnop'));
                return this.list;
            },
            "should fire the callback": function () {
                assert.isTrue(this.list.calledSliceCallback);
            }
        }
    }
}).export(module)